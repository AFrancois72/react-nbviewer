{"version":3,"sources":["../../src/index.tsx","index.js"],"names":["base64ToImage","mime","src","base64","DisplayDataOutput","datas","output","data","formats","raw","elements","r","className","styles","dataframe","React","key","hidx","scope","rowidx","row","idx","getDataFrame","format","datalines","svg","srcDoc","Array","Error","StreamOutput","ansiClassNames","30","31","32","33","34","35","36","37","ansi_white_fg","ErrorOutput","splitted","traceback","spans","lastClassName","ansiCode","codes","c","ansiCodeToClassName","i","s","CodeCell","cell","props","source","input_prompt","language","output_prompt","PlainMarkdown","PlainCode","NbViewer","markdown","code","ipynb","JSON","MathMarkdown","renderers","math","value","inlineMath","plugins","MathPlugin","App","useState","setSource","useEffect","fetch","process","then","text","Highlighter","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.6ee03c32.chunk.js","sourcesContent":["import React, { Fragment } from 'react'\nimport styles from './index.css'\n\nconst base64ToImage = (mime: string, base64: string) => (\n  <img src={`data:${mime};base64,${base64}`} />\n)\n\n// Putting the 'text/html' output on page is ugly and unsafe\n// Instead, let's parse the raw output\nfunction getDataFrame(raw: string) {\n  const rows = raw.split('\\n')\n  const elements = rows.map(r => r.split('  '))\n  return (\n    <table className={`dataframe ${styles.dataframe}`}>\n      <thead>\n        <tr>\n          <td />\n          {/* Column headers */}\n          {elements[0].slice(1).map((h, hidx) => <th key={hidx} scope=\"col\">{h}</th>)}\n        </tr>\n      </thead>\n      <tbody>\n        {elements.slice(1).map((row, rowidx) => (\n          <tr key={rowidx}>\n            {/* Row header */}\n            <th scope=\"row\">{row[0]}</th>\n            {row.slice(1).map((d, idx) => <td key={idx}>{d}</td>)}\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  )\n}\n\nconst DisplayDataOutput = ({ output }: {\n  output: NbDisplayDataOutput\n}) => {\n  const { data: datas } = output\n  const formats = ['text/html', 'image/svg+xml', 'image/png', 'image/jpeg', 'text/plain']\n  // e.g. pandas.DataFrame\n  if ((formats[0] in datas) && (formats[4] in datas)) {\n    return getDataFrame(datas[formats[4]].join(''))\n  }\n  for (const format of formats) {\n    if (format in datas) {\n      const datalines = datas[format]\n      if (format === 'image/svg+xml') {\n        const svg = datalines.join('')\n        return <img src={`data:image/svg+xml;utf8,${svg}`} />\n      }\n      if (format === 'text/html')\n        return <iframe srcDoc={datalines.join('')}></iframe>\n      if (format.startsWith('image/')) {\n        if (Array.isArray(datalines))\n          return base64ToImage(format, datalines[0])\n        return base64ToImage(format, datalines)\n      }\n      return <pre><code>{datalines.join('')}</code></pre>\n    }\n  }\n  throw new Error('Unsupported output format')\n}\n\nconst StreamOutput = ({ output }: { output: NbStreamOutput }) => {\n  const className = `output_stream ${styles.output_stream} ${\n    output.name === 'stderr' ? `output_stderr ${styles.output_stderr}` : ''\n    }`\n  return (\n    <div className={className}>\n      <pre>{output.text.join('')}</pre>\n    </div>\n  )\n}\n\nconst ansiClassNames = {\n  30: `ansi_black_fg ${styles.ansi_black_fg}`,\n  31: `ansi_red_fg ${styles.ansi_red_fg}`,\n  32: `ansi_green_fg ${styles.ansi_green_fg}`,\n  33: `ansi_yellow_fg ${styles.ansi_yellow_fg}`,\n  34: `ansi_blue_fg ${styles.ansi_blue_fg}`,\n  35: `ansi_magenta_fg ${styles.ansi_magenta_fg}`,\n  36: `ansi_cyan_fg ${styles.ansi_cyan_fg}`,\n  37: `ansi_white_fg ${styles.ansi_white_fg}`,\n}\n\nfunction ansiCodeToClassName(ansiCode: string) {\n  const codes = ansiCode.slice(2, -1).split(';')\n  if (codes === ['0'])\n    return null\n  return codes.map(c => ansiClassNames[c]).join(' ')\n}\n\nconst ErrorOutput = ({ output }: { output: NbErrorOutput }) => {\n  // Some ANSI escape codes are used to colorize the error output\n  // \\033[SGR;FG;BGm\n  const r = /(\\x1b\\[.+?m)/g\n  const traceback = output.traceback.join('')\n  const splitted = traceback.split(r)\n  const spans: React.ReactChild[] = []\n  let lastClassName: string | null = null\n  splitted.forEach((s, i) => {\n    if (r.test(s)) {\n      lastClassName = ansiCodeToClassName(s)\n      return\n    }\n    if (!lastClassName) spans.push(s)\n    else spans.push(<span className={lastClassName} key={i}>{s}</span>)\n  })\n  return <pre>{spans}</pre>\n}\n\ninterface CodeComponentProps {\n  language: string\n  children: string\n}\n\nconst CodeCell = ({ cell, ...props }: {\n  cell: NbCodeCell,\n  language: string,\n  code: React.ElementType<CodeComponentProps>\n}) => {\n  const source = cell.source.join('')\n\n  return (\n    <Fragment>\n      <tr>\n        {/* \"In [...]:\" for every code cell */}\n        <td className={`input_prompt ${styles.input_prompt}`}>\n          <pre>{`In [${cell.execution_count || ' '}]:`}</pre>\n        </td>\n        <td>\n          <props.code language={props.language}>{source}</props.code>\n        </td>\n      </tr>\n      {cell.outputs.map((output, i) => {\n        return (\n          <tr key={i}>\n            <td className={`output_prompt ${styles.output_prompt}`}><pre>\n              {output.output_type === 'execute_result' ?\n                `Out[${output.execution_count}]:` : ''}\n            </pre></td>\n            <td>\n              {(() => {\n                switch (output.output_type) {\n                  // The only difference between these two is \"Out[...]:\"\n                  case 'execute_result':\n                  case 'display_data':\n                    return <DisplayDataOutput output={output} />\n                  case 'stream':\n                    return <StreamOutput output={output} />\n                  case 'error':\n                    return <ErrorOutput output={output} />\n                  default:\n                    return undefined\n                }\n              })()}\n            </td>\n          </tr>\n        )\n      })}\n    </Fragment>\n  )\n}\n\ninterface MarkdownProps {\n  source: string\n}\n\ninterface NbViewerProps {\n  source: string | NbFormat,\n  markdown?: React.ElementType<MarkdownProps>,\n  code?: React.ElementType<CodeComponentProps>\n}\n\nexport default function NbViewer({\n  source,\n  markdown = PlainMarkdown,\n  code = PlainCode\n}: NbViewerProps) {\n  if (!source) return null\n  const ipynb: NbFormat = typeof source === 'string' ? JSON.parse(source) : source\n  // TODO: support more versions\n  if (ipynb.nbformat !== 4)\n    throw new Error('react-nbviewer currently supports nbformat 4 only')\n\n  const language =\n    ipynb.metadata.kernelspec?.language ||\n    ipynb.metadata.language_info?.name || 'python'\n\n  return (\n    <table>\n      <tbody>\n        {ipynb.cells.map((cell, i) => (\n          cell.cell_type === 'code' ?\n            <CodeCell cell={cell} language={language} code={code} key={i} /> :\n\n            <tr key={i}>\n              <td />\n              <td>{\n                // Not using JSX here because \"markdown\" is in lower case\n                React.createElement(markdown, {\n                  source: cell.source.join(''),\n                  key: i\n                }, null)\n              }</td>\n            </tr>\n        ))}\n      </tbody>\n    </table>\n  )\n}\n\n// Defaults when not provided\nfunction PlainMarkdown(props: MarkdownProps) {\n  return <div>{props.source}</div>\n}\n\nfunction PlainCode(props: CodeComponentProps) {\n  return <pre><code>{props.children}</code></pre>\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport NbViewer from 'react-nbviewer'\nimport Markdown from 'react-markdown'\nimport MathPlugin from 'remark-math'\nimport { InlineMath, BlockMath } from 'react-katex'\nimport Highlighter from 'react-syntax-highlighter'\n\nimport 'react-nbviewer/dist/index.css'\nimport 'katex/dist/katex.min.css'\n\nconst MathMarkdown = (props) => {\n  const renderers = {\n    math: ({ value }) => <BlockMath math={value} />,\n    inlineMath: ({ value }) => <InlineMath math={value} />,\n    code: props =>\n      <Highlighter language={props.language}>{props.value}</Highlighter>\n  }\n  return (\n    <Markdown\n      renderers={renderers}\n      plugins={[MathPlugin]}\n      source={props.source} />\n  )\n}\n\nconst App = () => {\n  const [source, setSource] = React.useState('')\n  React.useEffect(() => {\n    fetch(process.env.PUBLIC_URL + '/example.ipynb')\n      .then(src => src.text())\n      .then(src => setSource(src))\n  }, [])\n  return <NbViewer source={source} markdown={MathMarkdown} code={Highlighter} />\n}\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}