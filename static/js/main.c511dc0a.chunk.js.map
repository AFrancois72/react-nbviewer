{"version":3,"sources":["../../src/index.tsx","index.js"],"names":["base64ToImage","mime","src","base64","DisplayDataOutput","datas","output","data","formats","raw","elements","rows","r","className","styles","dataframe","React","key","hidx","scope","rowidx","row","idx","getDataFrame","format","datalines","svg","srcDoc","Array","Error","StreamOutput","output_stream","ansiClassNames","30","31","32","33","34","35","36","37","ansi_white_fg","ErrorOutput","splitted","traceback","spans","lastClassName","ansiCode","codes","c","ansiCodeToClassName","i","s","CodeCell","props","source","cell","input_prompt","language","output_prompt","PlainMarkdown","PlainCode","markdown","code","ipynb","JSON","MathMarkdown","renderers","math","value","inlineMath","plugins","MathPlugin","App","useState","setSource","useEffect","fetch","process","then","text","dragged","setDragged","readFile","file","reader","FileReader","onload","e","target","result","readAsText","onDragOver","event","stopPropagation","preventDefault","onDrop","dataTransfer","files","onDragEnter","style","padding","border","backgroundColor","type","onChange","accept","Highlighter","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.c511dc0a.chunk.js","sourcesContent":["import React, { Fragment } from 'react'\nimport styles from './index.css'\n\nconst base64ToImage = (mime: string, base64: string) => (\n  <img src={`data:${mime};base64,${base64}`} />\n)\n\n// Putting the 'text/html' output on page is ugly and unsafe\n// Instead, let's parse the raw output\nfunction getDataFrame(raw: string) {\n  const rows = raw.split('\\n')\n  const elements = rows.map(r => r.split('  '))\n  return (\n    <table className={`dataframe ${styles.dataframe}`}>\n      <thead>\n        <tr>\n          <td />\n          {/* Column headers */}\n          {elements[0].slice(1).map((h, hidx) => <th key={hidx} scope=\"col\">{h}</th>)}\n        </tr>\n      </thead>\n      <tbody>\n        {elements.slice(1).map((row, rowidx) => (\n          <tr key={rowidx}>\n            {/* Row header */}\n            <th scope=\"row\">{row[0]}</th>\n            {row.slice(1).map((d, idx) => <td key={idx}>{d}</td>)}\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  )\n}\n\nconst DisplayDataOutput = ({ output }: {\n  output: NbDisplayDataOutput\n}) => {\n  const { data: datas } = output\n  const formats = ['text/html', 'image/svg+xml', 'image/png', 'image/jpeg', 'text/plain']\n  // e.g. pandas.DataFrame\n  if ((formats[0] in datas) && (formats[4] in datas)) {\n    return getDataFrame(datas[formats[4]].join(''))\n  }\n  for (const format of formats) {\n    if (format in datas) {\n      const datalines = datas[format]\n      if (format === 'image/svg+xml') {\n        const svg = datalines.join('')\n        return <img src={`data:image/svg+xml;utf8,${svg}`} />\n      }\n      if (format === 'text/html')\n        return <iframe srcDoc={datalines.join('')}></iframe>\n      if (format.startsWith('image/')) {\n        if (Array.isArray(datalines))\n          return base64ToImage(format, datalines[0])\n        return base64ToImage(format, datalines)\n      }\n      return <pre><code>{datalines.join('')}</code></pre>\n    }\n  }\n  throw new Error('Unsupported output format')\n}\n\nconst StreamOutput = ({ output }: { output: NbStreamOutput }) => {\n  const className = `output_stream ${styles.output_stream} ${\n    output.name === 'stderr' ? `output_stderr ${styles.output_stderr}` : ''\n    }`\n  return (\n    <div className={className}>\n      <pre>{output.text.join('')}</pre>\n    </div>\n  )\n}\n\nconst ansiClassNames = {\n  30: `ansi_black_fg ${styles.ansi_black_fg}`,\n  31: `ansi_red_fg ${styles.ansi_red_fg}`,\n  32: `ansi_green_fg ${styles.ansi_green_fg}`,\n  33: `ansi_yellow_fg ${styles.ansi_yellow_fg}`,\n  34: `ansi_blue_fg ${styles.ansi_blue_fg}`,\n  35: `ansi_magenta_fg ${styles.ansi_magenta_fg}`,\n  36: `ansi_cyan_fg ${styles.ansi_cyan_fg}`,\n  37: `ansi_white_fg ${styles.ansi_white_fg}`,\n}\n\nfunction ansiCodeToClassName(ansiCode: string) {\n  const codes = ansiCode.slice(2, -1).split(';')\n  if (codes === ['0'])\n    return null\n  return codes.map(c => ansiClassNames[c]).join(' ')\n}\n\nconst ErrorOutput = ({ output }: { output: NbErrorOutput }) => {\n  // Some ANSI escape codes are used to colorize the error output\n  // \\033[SGR;FG;BGm\n  const r = /(\\x1b\\[.+?m)/g\n  const traceback = output.traceback.join('')\n  const splitted = traceback.split(r)\n  const spans: React.ReactChild[] = []\n  let lastClassName: string | null = null\n  splitted.forEach((s, i) => {\n    if (r.test(s)) {\n      lastClassName = ansiCodeToClassName(s)\n      return\n    }\n    if (!lastClassName) spans.push(s)\n    else spans.push(<span className={lastClassName} key={i}>{s}</span>)\n  })\n  return <pre>{spans}</pre>\n}\n\ninterface CodeComponentProps {\n  language: string\n  children: string\n}\n\nconst CodeCell = ({ cell, ...props }: {\n  cell: NbCodeCell,\n  language: string,\n  code: React.ElementType<CodeComponentProps>\n}) => {\n  const source = cell.source.join('')\n\n  return (\n    <Fragment>\n      <tr>\n        {/* \"In [...]:\" for every code cell */}\n        <td className={`input_prompt ${styles.input_prompt}`}>\n          <pre>{`In [${cell.execution_count || ' '}]:`}</pre>\n        </td>\n        <td>\n          <props.code language={props.language}>{source}</props.code>\n        </td>\n      </tr>\n      {cell.outputs.map((output, i) => {\n        return (\n          <tr key={i}>\n            <td className={`output_prompt ${styles.output_prompt}`}><pre>\n              {output.output_type === 'execute_result' ?\n                `Out[${output.execution_count}]:` : ''}\n            </pre></td>\n            <td>\n              {(() => {\n                switch (output.output_type) {\n                  // The only difference between these two is \"Out[...]:\"\n                  case 'execute_result':\n                  case 'display_data':\n                    return <DisplayDataOutput output={output} />\n                  case 'stream':\n                    return <StreamOutput output={output} />\n                  case 'error':\n                    return <ErrorOutput output={output} />\n                  default:\n                    return undefined\n                }\n              })()}\n            </td>\n          </tr>\n        )\n      })}\n    </Fragment>\n  )\n}\n\ninterface MarkdownProps {\n  source: string\n}\n\ninterface NbViewerProps {\n  source: string | NbFormat,\n  markdown?: React.ElementType<MarkdownProps>,\n  code?: React.ElementType<CodeComponentProps>\n}\n\nexport default function NbViewer({\n  source,\n  markdown = PlainMarkdown,\n  code = PlainCode\n}: NbViewerProps) {\n  if (!source) return null\n  const ipynb: NbFormat = typeof source === 'string' ? JSON.parse(source) : source\n  // TODO: support more versions\n  if (ipynb.nbformat !== 4)\n    throw new Error('react-nbviewer currently supports nbformat 4 only')\n\n  const language =\n    ipynb.metadata.kernelspec?.language ||\n    ipynb.metadata.language_info?.name || 'python'\n\n  return (\n    <table>\n      <tbody>\n        {ipynb.cells.map((cell, i) => (\n          cell.cell_type === 'code' ?\n            <CodeCell cell={cell} language={language} code={code} key={i} /> :\n\n            <tr key={i}>\n              <td />\n              <td>{\n                // Not using JSX here because \"markdown\" is in lower case\n                React.createElement(markdown, {\n                  source: cell.source.join(''),\n                  key: i\n                }, null)\n              }</td>\n            </tr>\n        ))}\n      </tbody>\n    </table>\n  )\n}\n\n// Defaults when not provided\nfunction PlainMarkdown(props: MarkdownProps) {\n  return <div>{props.source}</div>\n}\n\nfunction PlainCode(props: CodeComponentProps) {\n  return <pre><code>{props.children}</code></pre>\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport NbViewer from 'react-nbviewer'\nimport Markdown from 'react-markdown'\nimport MathPlugin from 'remark-math'\nimport { InlineMath, BlockMath } from 'react-katex'\nimport Highlighter from 'react-syntax-highlighter'\n\nimport 'react-nbviewer/dist/index.css'\nimport 'katex/dist/katex.min.css'\n\nconst MathMarkdown = (props) => {\n  const renderers = {\n    math: ({ value }) => <BlockMath math={value} />,\n    inlineMath: ({ value }) => <InlineMath math={value} />,\n    code: props =>\n      <Highlighter language={props.language}>{props.value}</Highlighter>\n  }\n  return (\n    <Markdown\n      renderers={renderers}\n      plugins={[MathPlugin]}\n      source={props.source} />\n  )\n}\n\nconst App = () => {\n  const [source, setSource] = React.useState('')\n  React.useEffect(() => {\n    fetch(process.env.PUBLIC_URL + '/example.ipynb')\n      .then(src => src.text())\n      .then(src => setSource(src))\n  }, [])\n  const [dragged, setDragged] = React.useState(false)\n\n  function readFile(file) {\n    if (!file)\n      return\n    const reader = new FileReader()\n    reader.onload = (e) =>\n      setSource(e.target.result)\n    reader.readAsText(file)\n  }\n  function onInputChange(event) {\n    event.preventDefault()\n    readFile(event.target.files[0])\n  }\n  function onDrop(event) {\n    event.preventDefault()\n    readFile(event.dataTransfer.files[0])\n    setDragged(false)\n  }\n  function onDragOver(event) {\n    event.stopPropagation()\n    event.preventDefault()\n  }\n  function onDragEnter(event) {\n    event.stopPropagation()\n    event.preventDefault()\n    setDragged(true)\n  }\n\n  return (\n    <div\n      onDragOver={onDragOver}\n      onDrop={onDrop}>\n      <div onDragEnter={onDragEnter} style={{\n        padding: 20,\n        border: '1px solid #999',\n        backgroundColor: dragged ? '#ddd' : '#efefef'\n      }}>\n        <span>Drag and drop file here or </span>\n        <input type=\"file\" onChange={onInputChange}\n          accept=\".ipynb,application/x-ipynb+json\" />\n      </div>\n      <NbViewer source={source} markdown={MathMarkdown} code={Highlighter} />\n    </div>\n  )\n}\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}